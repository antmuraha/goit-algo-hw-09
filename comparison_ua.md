# Порівняння ефективності жадібного алгоритму та алгоритму динамічного програмування

## Часова складність

### Жадібний алгоритм:

-   Часова складність: O(len(coins)).

-   Алгоритм просто проходить по відсортованому списку монет один раз, тому його складність залежить лише від кількості монет, а не від суми.
    Це робить його дуже швидким навіть для великих сум.

### Динамічне програмування:

-   Часова складність: O(sum \* len(coins)).

-   Алгоритм заповнює DP-масив для кожної можливої суми від 0 до sum, що робить його значно повільнішим для великих сум.

## Продуктивність при великих сумах

### Жадібний алгоритм:

Працює дуже швидко навіть для великих сум, оскільки його складність не залежить від значення sum.
Наприклад, для суми 1,000,000 і монет [50, 25, 10, 5, 1] жадібний алгоритм виконається майже миттєво.

### Динамічне програмування:

Для великих сум (наприклад, 1,000,000) алгоритм стає непрактичним через високу часову та просторову складність.
Наприклад, для суми 1,000,000 і монет [50, 25, 10, 5, 1] DP-алгоритму потрібно буде обробити мільйон елементів у DP-масиві, що займе багато часу та пам'яті.

## Ефективність алгоритмів

### Жадібний алгоритм:

Ефективний для великих сум, оскільки його складність не залежить від значення sum.
Однак він працює лише для "канонічних" систем монет (наприклад, [50, 25, 10, 5, 1]), де локально оптимальний вибір завжди призводить до глобально оптимального рішення.

### Динамічне програмування:

Ефективний для малих сум або для систем монет, де жадібний алгоритм не працює (наприклад, [10, 6, 1]).
Для великих сум DP-алгоритм стає неефективним через високу часову та просторову складність.

## Висновок

Для великих сум: Жадібний алгоритм значно ефективніший, оскільки його час виконання не залежить від значення sum.

Для малих сум або нестандартних систем монет: Динамічне програмування є кращим вибором, оскільки воно гарантує оптимальне рішення.
